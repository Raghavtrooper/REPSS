import os
import shutil
import sys
import time
import logging # Use standard logging module

# Add project root to sys.path to ensure shared module is discoverable
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(os.path.dirname(current_dir)) # Go up two levels from app/vector_utils.py to REPSS_raghav
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)


from langchain_community.embeddings import SentenceTransformerEmbeddings
# Changed from Chroma to Qdrant
from langchain_community.vectorstores import Qdrant
from qdrant_client import QdrantClient, models

# Import configuration from shared module
from shared.config import QDRANT_HOST, QDRANT_PORT, QDRANT_API_KEY, QDRANT_COLLECTION_NAME

def get_vectorstore():
    """
    Initializes or connects to the Qdrant vector store.
    Expects Qdrant service to be running and collection to be pre-generated by the ETL process.
    Logs warnings and raises exceptions if connection fails or collection is empty.
    """
    embedding_function = SentenceTransformerEmbeddings(model_name="all-MiniLM-L6-v2")

    try:
        logger.info(f"Connecting to Qdrant at {QDRANT_HOST}:{QDRANT_PORT}...")
        
        # Initialize Qdrant client
        # For local Qdrant, `host` and `port` are usually sufficient.
        # For cloud Qdrant, `url` and `api_key` would be used.
        client = QdrantClient(
            host=QDRANT_HOST,
            port=QDRANT_PORT,
            api_key=QDRANT_API_KEY, # Pass API key if configured
            timeout=10 # Add a timeout for connection
        )

        # Check if the collection exists
        try:
            collection_info = client.get_collection(collection_name=QDRANT_COLLECTION_NAME)
            logger.info(f"Qdrant collection '{QDRANT_COLLECTION_NAME}' found. Status: {collection_info.status.value}")
            if collection_info.points_count == 0:
                logger.warning(
                    f"Qdrant collection '{QDRANT_COLLECTION_NAME}' is empty. "
                    "Please run the ETL process first to populate it."
                )
            else:
                logger.info(f"Qdrant collection loaded successfully with {collection_info.points_count} documents.")

        except Exception as e:
            logger.error(f"Qdrant collection '{QDRANT_COLLECTION_NAME}' not found or inaccessible: {e}")
            raise RuntimeError(
                f"Qdrant collection '{QDRANT_COLLECTION_NAME}' not found or inaccessible. "
                "Please ensure the ETL process has run to create and populate it."
            ) from e

        # Initialize LangChain Qdrant vector store
        # Added metadata_payload_key=None to ensure all payload fields are retrieved as metadata
        vectorstore = Qdrant(
            client=client,
            collection_name=QDRANT_COLLECTION_NAME,
            embeddings=embedding_function,
            metadata_payload_key=None # Explicitly tell Qdrant to use the entire payload as metadata
        )

    except Exception as e:
        logger.exception(f"Error connecting to Qdrant at {QDRANT_HOST}:{QDRANT_PORT}: {e}")
        raise RuntimeError(
            f"Failed to connect to Qdrant. Please ensure the Qdrant service is running at {QDRANT_HOST}:{QDRANT_PORT}."
        ) from e

    return vectorstore
